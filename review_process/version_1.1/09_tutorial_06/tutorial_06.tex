% Tutorial 06

\subsection{Tutorial 6: NN(QM)/MM simulations with the BuRNN approach}
The Buffer Region Neural Network (BuRNN) approach \cite{Lier2022BuRNN} is a hybrid quantum mechanics/molecular mechanics (QM/MM) \cite{Warshel1976QM/MM, Senn2009QM/MM} simulation method. The system is therefore partitioned into regions having different levels of theory, a QM and a classical MM region. 

In-between the two regions (inner and outer) an additional buffer region is introduced to be treated at both levels of theory (Figure~\ref{BuRNN_scheme}, a). The inner region itself and the interactions between it and the buffer region are described by an atomistic neural network (NN) model.

The total potential energy of the system is calculated as follows:

\begin{equation}
  \begin{aligned}
  V_{tot} = V^{QM}_{\mathbb{I+B}} - V^{QM}_{\mathbb{B}} + V^{MM}_{\mathbb{B}} + V^{MM}_{\mathbb{O}}
    \end{aligned}
\end{equation}

 The energy difference of the first two terms is directly described by a neural network potential: 
 
\begin{equation}
  \begin{aligned}
  V_{tot} \cong \mathrm{V}_{\mathbb{I+}\Delta\mathbb{B}}^{NN} + \mathrm{V}_{\mathbb{B+O}}^{MM}
    \end{aligned}
\end{equation}

 As a NN model we use SchNet \cite{Schuett2017SchNet, Schuett2018SchNet,Schuett2019SPK}, a deep learning architecture implemented in the MD engine of GROMOS.
 
In this tutorial, methanol in water will be used as a model system. In the context of BuRNN, we will have methanol in the inner region, while water molecules in the 0.5 nm radius around the methanol will form the buffer region. The rest of the box will belong to the outer region. We will learn how to install GROMOS with the interface to SchNetPack, generate a training data set, train the NN model and run the BuRNN simulation.

\begin{figure}[H]
\centering
\includegraphics[scale=.33]{../09_tutorial_06/figures/BuRNN_scheme}
\caption{(a) BuRNN scheme with its three regions: Inner region (orange) described by quantum mechanics (QM), buffer region (blue) described by QM and classical molecular mechanics (MM), outer region (grey) described by MM. (b) Test system: methanol solvated in SPC water. Methanol therefore builds the inner region, two shells of water will be the buffer region, the rest of the water box serves as outer region.}
\label{BuRNN_scheme}
\end{figure}


\subsubsection{Installation}
\paragraph{Prerequisites}
To compile and install GROMOS with the interface to SchNetPack (spk) to run NN models, you first need to have installed SchNetPack and the pybind11 library. The interface uses the pybind11 library to call the model prediction functions in the Python code of SchNetPack. To install the SchNetPack and pybind11 library on your system, please follow their installation. Tested version of SchNetPack is 1.0.0 and pybind11 v2.6.2.

\paragraph{GPU acceleration}
This part is optional to improve the efficiency of the simulations. The tasks in this tutorial are small enough to be run CPU-only in reasonable time. For the production runs this is inefficient since the training and evaluation of models on a GPU is usually many-folds faster. NN/MM MD simulations in GROMOS profit from this as well. Unfortunately, setting up your system to support the GPU acceleration is strongly architecture specific and is dependent on the installed CUDA and Pytorch versions. Please follow the installation instructions of CUDA and Pytorch to run tasks with the GPU acceleration.

\paragraph{GROMOS compilation}
Compilation of the NN-enabled version of GROMOS is activated by the \texttt{--enable-schnetpack} flag in the configuration step. The \texttt{configure} script looks up the pybind11 library automatically; however, based on the versions of the packages and the architecture, it might not be found. In that case you should provide the flags \texttt{PYFLAGS} and \texttt{PYLDFLAGS} to the \texttt{configure} script. The \texttt{PYFLAGS} variable holds the C preprocessor flags, which can be obtained by calling

\begin{lstlisting}[breaklines=true, breakatwhitespace=false]
python3 -m pybind11 --includes
\end{lstlisting}

The \texttt{PYLDFLAGS} are the linker flags. Depending on the Python version, they can be generated by calling either 

\begin{lstlisting}[breaklines=true, breakatwhitespace=false]
python3-config --ldflags
\end{lstlisting}

for Python<3.8, or 

\begin{lstlisting}[breaklines=true, breakatwhitespace=false]
python3-config --ldflags --embed
\end{lstlisting}

for newer versions. An example of the \texttt{configure} script then could be:
\begin{lstlisting}[breaklines=true, breakatwhitespace=false]
$ ./configure --enable-schnetpack PYFLAGS='-I/path/to/include/python3.7 -I/path/to/lib/python3.7/site-packages/pybind11/include' PYLDFLAGS='-L/path/to/lib/python3.7/config -L/path/to/lib -lpython3.7 -lcrypt -lpthread -ldl -lutil -lrt -lm'
\end{lstlisting}

Further steps follow the standard compilation:
\begin{lstlisting}[breaklines=true, breakatwhitespace=false]
$ make
$ make install
\end{lstlisting}


\subsubsection{Training data set generation and model training}
The BuRNN approach replaces expensive QM calculations with NN prediction. In order to train NN models, QM data points for building a training data set have to be generated first. In this tutorial, an example QM training data set has been generated using the semi-empirical program MOPAC\cite{Stewart1990MOPAC, Stewart2013MOPAC}. In practice, the choice of the QM software to be used is entirely up to the user. However, in order to prepare the training data set in a reasonable time, it is necessary to automate the QM calculations. In addition, it takes a certain amount of time to perform the QM calculations for all the snapshots generated by MD. Therefore, a small \href{https://github.com/LierB/gromos_tutorial_livecoms/tree/burnn_tutorial_rc/tutorial_files/t_06/train_dataset_tutorial/QM_dataset_example}{QM data set} has been prepared in advance for you. The entire process is described in the following section.
%We decided to use semi-empirical QM calculations to present the BuRNN approach in this tutorial, as it takes least computational resources. We will run in it with the MOPAC \cite{Stewart1990MOPAC, Stewart2013MOPAC} program. Usually the user decides which reference method will be used, depending on the system and the accuracy requirements.

This tutorial will be accompanied by the \href{https://github.com/LierB/gromos_tutorial_livecoms/blob/burnn_tutorial_rc/tutorial_files/t_06/train_dataset_tutorial/tutorial_v2.ipynb}{jupyter notebook} to give you a hands-on example of the building of the training database. It will use in-house written Python module \href{https://github.com/LierB/gromos_tutorial_livecoms/blob/burnn_tutorial_rc/tutorial_files/t_06/train_dataset_tutorial/additional_spk_utils.py}{\texttt{additional\_spk\_utils}} for building the training data set.

\paragraph{Extracting the QM regions from MD trajectory}
The resulting QM data set will contain the inner plus buffer (IPB) region and the buffer region for each training configuration. Our protocol for creating such a dataset is as follows: 
\begin{enumerate}
    \item Classical MD simulation of the system of interest.
    \item Extraction of the IPB regions from the MD trajectory.
    \item QM energy minimization for all (or selected) the extracted IPB regions.
    \item Including all the minimization steps into the data set.
    \item Extraction of the buffer regions from all the data points.
    \item Single-Point (SP) QM calculations for the IPB and buffer regions separately.
    \item Creation of the training database
\end{enumerate}
%In the first step classical MD simulations of the system are run as described in tutorial 1. Explicit hydrogen atoms need to be added for subsequent QM calculations. The required files for the simulations are provided.
%\texttt{meoh.top}, \texttt{meoh.cnf}, \texttt{em_solute.imd}, \texttt{em_solute.run}, \texttt{sim_box.arg}, \texttt{sim_box.arg}, \texttt{em_solvent.imd}, \texttt{em_solvent.run},... 
The classical MD simulation was performed as described in Tutorial 1. QM regions (inner + buffer regions) were extracted using the GROMOS++ program \texttt{filter} from each snapshot of the MD trajectory. The program writes out coordinate trajectories for atoms that are within a specified distance of a certain part of the system (all into one \href{https://github.com/LierB/gromos_tutorial_livecoms/blob/burnn_tutorial_rc/tutorial_files/t_06/train_dataset_tutorial/filter/filter_output_example.cnf}{file}).

For methanol, all methanol atoms were used as filtering centers (\texttt{@atoms 1:a}). The system was filtered with a chargegroup-based cutoff (\texttt{@pairlist CHARGEGROUP}) of 0.5 nm radius (\texttt{@cutoff 0.5}). The optimal/reasonable size for the buffer region can be determined from an rdf analysis. It should be as small as possible, as we want to save computational effort for the following QM calculations. The chargegroup cutoff scheme is important as we want to include full water molecules in the QM calculations. Then we extracted individual QM regions into separated configuration files using an in-house written Python script.

\begin{lstlisting}[breaklines=true, breakatwhitespace=false]
@topo       your path to the topology file
@pbc        r cog
@atoms      1:a
@pairlist   CHARGEGROUP
@cutoff     0.5
@outformat  cnf
@traj       you path(s) to the trajectory file(s)
\end{lstlisting}

\href{https://github.com/LierB/gromos_tutorial_livecoms/tree/burnn_tutorial_rc/tutorial_files/t_06/train_dataset_tutorial/separated_cnf_files}{Here} we provided an example of the 2 configuration files which will be used further in this tutorial. An example of the \href{https://github.com/LierB/gromos_tutorial_livecoms/blob/burnn_tutorial_rc/tutorial_files/t_06/train_dataset_tutorial/filter/filter_meoh_example.arg}{argument file} for the \texttt{filter} is also provided.

\paragraph{QM calculations}
In this part we mainly focus on the concept of QM geometry optimization (GO) and single point calculations (SP) in the context of BuRNN. Once we have the coordinates of the IPB region, GO will optimize the atomic positions to find the local minimum of the QM potential energy surface. This calculation will not only find the local energy minimum but also connects the classical snapshots with the optimal QM conformations and thus represents a sufficient part of the conformational space of the system. Therefore we included all the optimization steps into the training dataset, but we needed to be aware that the training data set will be significantly increased in size. A lot of similar structures will be present at the end of the minimization and thus clustering before proceeding with the next step is recommended. We used MOPAC with the following keywords to perform the GO:

\begin{lstlisting}[breaklines=true, breakatwhitespace=false]
PM7 GRAD AUX(PRECISION = 9, XP, XS, XW) CHARGE=0
\end{lstlisting}

For each (remaining) optimization step, a single point (SP) QM calculation is required to receive the associated QM energy and gradients (forces). The SP calculation is not only done for the IPB region but also for the buffer region alone. The coordinates of the buffer region are identical for the two calculations. The number of atoms for the inner region was required, as these atoms needed to be deleted for the second calculation (buffer region only). Furthermore, the geometry of water molecules in the buffer region needed to be preserved as in the following BuRNN simulations the bonds will be constrained by the SHAKE algorithm\cite{RYCKAERT1977SHAKE}. The following MOPAC keywords were used for the SP calculations:

\begin{lstlisting}[breaklines=true, breakatwhitespace=false]
PM7 GRAD AUX(PRECISION = 9, XP, XS, XW) 1SCF CHARGE=0
\end{lstlisting}

The whole process of GO and subsequent SP calculations was automated by a self-written Python module. The examples of the \href{https://github.com/LierB/gromos_tutorial_livecoms/tree/burnn_tutorial_rc/tutorial_files/t_06/train_dataset_tutorial/MOPAC_minimzation_files}{GO outputs} and \href{https://github.com/LierB/gromos_tutorial_livecoms/tree/burnn_tutorial_rc/tutorial_files/t_06/train_dataset_tutorial/QM_dataset_example}{SP outputs} were provided. GO was performed for 2 previously mentioned MD configurations. However, the size of the data set increased to 860 configurations after including the GO optimization steps.

\paragraph{Building a training database}
In this chapter we will explain how to build the ASE (atomic simulation environment) \cite{Larsen2017ASE} database from the previously calculated energies and forces of the snapshots. The procedure is described in more detail in the \href{https://github.com/LierB/gromos_tutorial_livecoms/blob/burnn_tutorial_rc/tutorial_files/t_06/train_dataset_tutorial/tutorial_v2.ipynb}{jupyter notebook}. The \texttt{additional\_spk\_utils} module will be used for storing the relevant properties and metadata in the ASE database. 
%The absolute energies of the complex (inner + buffer region) and buffer, the energy differences between the two and the differences between the forces. Additionally we store reference energies (energies in vacuum) for all components in the QM zone separately. In our example it would be the energy of one methanol molecule in vacuum and of one water molecule in vacuum. 

%To calculate the interaction energy between inner region and buffer region, the reference energies are subtracted. Note that the number of water molecules in the buffer region has to be multiplied with the reference energy of one water molecule.


\paragraph{Model training}
The last step before running BuRNN simulations is the NN model training. In the previous parts, the ASE database was created based on structures from QM GO and SP calculations. We will now use SchNetPack for training of the example NN model. Due to the significant computational requirements of the NN model training we prepared fully trained \href{https://github.com/LierB/gromos_tutorial_livecoms/tree/burnn_tutorial_rc/tutorial_files/t_06/models}{NN models} in advance for you.

The SchNet model\cite{Schuett2018SchNet} is a convolutional neural network (CNN) with a continuous filter. It is very similar to the common CNNs used in image recognition, for instance. In contrast to the images, molecules cannot be described by the discrete matrix of pixels and thus the continuous filter is applied instead of a discrete one. The SchNet model is composed of two NNs. The main one is responsible for the prediction of the given property itself (input is the vector of atomic numbers for the given structure). The second one generates the filter for the convolution (input: positions of the individual atoms of the given structure). The main NN is divided into three main blocks. The first is the embedding layer which creates the feature vectors for the individual atoms within the structure (therefore the whole structure is represented by the 2D matrix of shape(number of atom-wise features, number of atoms)). The second part of the model is the series of the interaction blocks. One interaction block contains one convolutional layer. This block is responsible for creating the representation of the system. The last part is the output module which predicts the given property of the structure (in our case energy).

For the model training we use two scripts, a python \href{https://github.com/LierB/gromos_tutorial_livecoms/blob/burnn_tutorial_rc/tutorial_files/t_06/train_dataset_tutorial/spk_run.py}{\texttt{spk\_run.py}} and a bash \href{https://github.com/LierB/gromos_tutorial_livecoms/blob/burnn_tutorial_rc/tutorial_files/t_06/train_dataset_tutorial/train.sh}{\texttt{train.sh}} script which runs the python one with all the specified arguments. The python script loads the data from the previously prepared ASE database (argument datapath) and splits it into training, validation and test set (we will use 80, 10, 10\% of the dataset; argument split). The NN model is build by setting training hyperparameters. It is reasonable to use the default values to start with the training and then optimize them. The number of atom-wise features and the number of interaction blocks are the most important hyperparameters of the SchNet architecture, as they define the model complexity and therefore the precision and computational costs. In our case we will train very small model (arguments features and interactions) which will be trained only for 2 epochs (argument n\_epochs). The complete list of arguments (hyperparameters) for the \texttt{spk\_run.py} is listed in the \href{https://github.com/LierB/gromos_tutorial_livecoms/blob/burnn_tutorial_rc/tutorial_files/t_06/train_dataset_tutorial/tutorial_v2.ipynb}{jupyter notebook}. The following parameters are defined in our example training:
\begin{enumerate}
    \item[-] property = property to be predicted by the model (default energy)
    \item[-] derivative = derivative of the property to be predicted
    \item[-] rho = weigth factor for the property and derivative, respectively
    \item[-] split = determines how many training, validation and test data will be selected, the first value for training data size, the second for validation data size, the rest of the dataset is used for the model evaluation (default (None, None))
    \item[-] batch\_size = batch size (default 8)
    %\item[-] device = cpu or cuda (default 'cuda')
    \item[-] n\_epochs = maximum number of training epochs (default 5000)
    \item[-] lr = learning rate (default 0.0001)
    \item[-] lr\_patience = learning rate will be decreased after the certain number of epochs without improvement of the model (default 25)
    \item[-] lr\_min = minimal learning rate, when the value is reached, the training process is stopped (default 1e-06)
    \item[-] cutoff = cutoff for long-range interactions (default 5.0)
    \item[-] num\_gaussians = number of gaussians to describe (default 50)
    \item[-] features = number of atom-wise features (default 128)
    \item[-] interactions = number of interaction blocks (default 3)
\end{enumerate}

As we train on energies and forces, a combined loss function for optimizing the weight parameters will be used that predicts and obtains forces automatically as derivatives of the energies. For that a loss weight (argument rho) is introduced to control the trade-off between energy loss and force loss.

\begin{lstlisting}[breaklines=true, breakatwhitespace=false]
#!/bin/bash

datapath= your path to the ASE database
modelpath= your path where the model will be stored

# model training
python spk_run.py train schnet custom $datapath $modelpath --property energy --derivative forces --rho property=0.01 derivative=0.99 --split 688 86 --batch_size 8 --n_epochs 2 --lr 0.0001 --lr_patience 10 --lr_min 1e-06 --cutoff 100.0 --num_gaussians 50 --features 32 --interactions 1
\end{lstlisting}

The script also calls the \texttt{spk\_run.py} in the evaluation mode which evaluates the model against the test data.

\begin{lstlisting}[breaklines=true, breakatwhitespace=false]
# model evaluation
python spk_run.py eval $datapath $modelpath --split test --batch_size 1
\end{lstlisting}

Run the script to train and evaluate the example model.

\begin{lstlisting}[breaklines=true, breakatwhitespace=false]
$ ./train.sh
\end{lstlisting}

The training will produce several files in the model-path directory. The model, the evaluation file, a training log file, a file with the random split, a checkpoint file and a json file with the model settings. The checkpoint file is written periodically and can be used to restart the training. Typically, we train 2 NN models per BuRNN simulation. We use the second model to evaluate the predictions of the first model (see next section).

%For the BuRNN simulations we provided fully trained models that you can find in the 
%\texttt{path/provided\_models} directory.

%\paragraph{Model evaluation}
%??


\subsubsection{BuRNN simulation}
For the BuRNN simulation, the QM and buffer regions have to be defined. Therefore the QM atoms have to be specified and the buffer region has to be adjusted by setting a cutoff around the QM region. This information together with other specifications will be stored in an additional input file \texttt{meoh.qmm}:

\begin{lstlisting}[breaklines=true, breakatwhitespace=false]
TITLE
qmmm specification file for BuRNN  
END
QMUNIT
# QMULEN    QMUENE    QMUFOR    QMUCHR
     0.1     4.184     41.84       1.0
END
\end{lstlisting}

The \texttt{QMUNIT} block may convert units of the model by a conversion factor for distances (\texttt{QMULEN}), energies (\texttt{QMUENE}), forces (\texttt{QMUFOR}), and charges(\texttt{QMUCHR}).

\begin{lstlisting}[breaklines=true, breakatwhitespace=false]
NNDEVICE
auto
END
NNMODEL
/path/to/best_model
# MT LT
   0  1
END
NNVALID
/path/to/best_model2
# NUMSTP THRSH FCON 
       1   5.0  0.0
END
\end{lstlisting}

The paths to the provided NN models have to be specified. Moreover, additional parameters have to be set up. The \texttt{NNDEVICE} block decides if it should be run on cuda (gpu) or cpu. If you specify auto, it will try to find a gpu first, if it is not available, a cpu will be used. 
In the next block, \texttt{NNMODEL}, the path to the prediction model is specified. The model type (MT) is set to 0, meaning that BuRNN will be run with a single NN evaluation on the previously trained energy differences. It would also be possible to calculate differences just during the simulation in a combined model or even calculate it with QM on the fly by setting it to 1. The learning type (LT) is set to 1 for a standard calculation. 

The \texttt{NNVALID} block is optional. In this case, the path to the second (validation) model is introduced and the energy of the given configuration is also predicted by this model. The predictions of the prediction and validation models are compared to estimate the robustness of the prediction. The models have to be trained with the same hyperparameters and on the same data set (only the random split is different). 

Two models will be compared at every nth step (\texttt{NUMSTP}), and the difference will be deemed accurate if it is below the threshold (\texttt{THRSH}). If it’s above the threshold, the force constant (\texttt{FCON}) can be set positive which pushes back the atoms to a configuration that agrees better with both models. 

We will set the threshold to 4.184 kJ/mol, which reflects the chemical accuracy of 1 kcal/mol, and calculate the difference between the models at each time step. This can be easily changed if we need to generate coordinates that are not included in the training set or if the simulation is not stable yet. Once we have a stable simulation, we can e.g. check the differences every 100th step.

\begin{lstlisting}[breaklines=true, breakatwhitespace=false]
QMZONE
# CHG MULT
    0    1
# RESIDUE   ATOM     QMI   QMZ   QMLI
   1 MeOH   CA         1     6      0
   1 MeOH   OB         2     8      0
   1 MeOH   HA1        3     1      0
   1 MeOH   HA2        4     1      0
   1 MeOH   HA3        5     1      0
   1 MeOH   HB1        6     1      0
END
BUFFERZONE
# CHG MULT CUTOFF 
    0    1     0.5
# RESIDUE   ATOM     QMI   QMZ   QMLI
   1 SOLV   OW         7     8     0
   1 SOLV   HW1        8     1     0
   1 SOLV   HW2        9     1     0
   2 SOLV   OW        10     8     0
   2 SOLV   HW1       11     1     0
   2 SOLV   HW2       12     1     0
   ...
END
\end{lstlisting}

These blocks finally contain the atoms that are part of the inner region (\texttt{QMZONE}) and might be part of the buffer (\texttt{BUFFERZONE}). In the first line of both blocks, we specify the charge and multiplicity of the given zone. In the \texttt{BUFFERZONE} block we also define the cutoff which we chose to be 0.5 nm. According to the cutoff size, the atoms that are included in the \texttt{BUFFERZONE} block will become buffer atoms as soon as they cross the cutoff during the simulation.

In addition to the separate input file, the \texttt{md.imd} file requires a \texttt{QMMM} block:
\begin{lstlisting}[breaklines=true, breakatwhitespace=false]
QMMM
# NTQMMM NTQMSW RCUTQM NTWQMMM QMLJ QMCON      
 MMSCALE
       1      5    1.4       0    0     0
    -1.0
END
\end{lstlisting}

Most of the parameters are only relevant for conventional QM/MM simulations. Therefore, they are not explained in detail.
QM/MM hybrid simulations (with mechanical embedding) are enabled by setting the first parameter \texttt{NTQMMM=1}. \texttt{NTQMSW} determines which software will be used for the QM calculation. If \texttt{NTQMSW=5}, instead of a QM package (1-4), SchNetPack will be called. The cutoff determined by \texttt{RCUTQM} is only relevant for electrostatic or polarizable embeddings used by QM packages. \texttt{NTWQMMM} can be used if QM/MM related data should be written to a separate trajectory every nth step. For BuRNN simulations we don't want to calculate LJ between QM atoms \texttt{QMLJ=0}. Constraining the bond lengths in the QM zone is optional (\texttt{QMCON}). With \texttt{MMSCALE} we can scale MM charges (by a scaling factor), but if \texttt{MMSCALE<0} no scaling is applied.

%Provide following files:
%meoh.qmm
%meoh.imd
%mk_script.arg
%mk_script.lib (depending on the environment, activation of libs)

\subsubsection{BuRNN (example) analysis}
The trajectory files produced by the BuRNN simulation are the same as those produced by the standard MD simulation in GROMOS, meaning that we can perform any analysis. Here we decided to show hydrogen bonds and rdf between the methanol treated at the QM level and the MM water molecules around (Figure~\ref{BuRNN_ana}). The argument files for \href{https://github.com/LierB/gromos_tutorial_livecoms/blob/burnn_tutorial_rc/tutorial_files/t_06/md_burnn/ana/hbond/hbond_meoh.arg}{hbond} and \href{https://github.com/LierB/gromos_tutorial_livecoms/blob/burnn_tutorial_rc/tutorial_files/t_06/md_burnn/ana/rdf/rdf_ob_ow.arg}{rdf} GROMOS programs were provided.

\subsubsection{Advanced options}
\paragraph{Including a charge model}
For running BuRNN simulations with dynamic QM charges, charges first need to be calculated with the QM method of choice and included in the training dataset. A separate NN has to be trained for the charges. SchNet was therefore adapted and the version can be found in \href{https://github.com/juliawestermayr/schnetpack}{this repository}.
In the \texttt{charge.qmm} file the \texttt{NNCHARGE} block has to be added. 

\begin{lstlisting}[breaklines=true, breakatwhitespace=false]
NNCHARGE
/path/to/best/charge_model
# NUMSTP
       1
END
\end{lstlisting}
This block contains the path to the NN charge model and the charges should be updated at every nth step (\texttt{NUMSTP}). 

\begin{figure}[H]
\centering
\includegraphics[scale=.66]{../09_tutorial_06/figures/burnn_livecoms_v2.png}
\caption{\textbf{BuRNN simulation analysis. (a)} The number of hydrogen bonds formed between methanol and water for each snapshot of the trajectory. \textbf{(b)} Radial distribution function between the methanol's oxygen and all the oxygen atoms of the water molecules. The results are based on a 2 ns BuRNN simulation of the methanol on water.}
\label{BuRNN_ana}
\end{figure}

%\paragraph{Adaptive sampling}
